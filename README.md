# ChessRobot316
Данный проект представляет собой desktop - приложение (windows) / android mobile app для игры в шахматы с интеграцией взаимодействия с роботом манипулятором (робот-рука). Приложение написано на фреймворке Flutter, взаимодействие с роботом осуществляется с помощью tcp/ip протокола.

## Технологии
- [Flutter](https://flutter.dev)

## Использование
Для того, чтобы приложение было играбельным и соответсвовало заявленным функциям в первую очередь необходимо подключить свой девайс (ноутбук или пк на windows / android смартфон) к сети CST316, так как эта сеть скрыта, ее нужно добавить на устройстве с помощью соответсвующей настройки, пароль необходимо уточнить у преподавателя. 

После того как Вы подключились к сети можно устанавливать приложение на устройство, если это не сделано раньше и запускать его.

Запустив приложение начинается игра. Нажав на фигуру, поля, являющимися возможными для хода подсвечиваются зеленым, нажав на такое поле, фигура перемещается на экране, в этот же момент робот манипулятор осуществялет точно такой же ход на самом стенде. Пользователь не имеет возможности сделать следующий ход, пока робот не выполнит закончит ход.
## Разработка

### Установка зависимостей
Для установки зависимостей, выполните команду:
```sh
$ flutter pub get
```
Для запуска проекта для windows, выполните команду:
```sh
$ flutter run -d windows
```
Для запуска проекта для android, выполните команду:
```sh
$ flutter run -d android
```

### Зачем мы разработали этот проект?
Чтобы получить зачет и оживить интерфейс для взаимодействя с роботом.

### Зависимости, библиотеки
Все зависимости можно посмотреть в файле pubspec.yaml

### Процесс разработки и подводные камни
Процесс разработки этого проекта включал следующие ключевые области:

1. **Реализация логики игры**: Создание шахматной доски, фигур и правил, управляющих их движением и взаимодействием.
2. **Интеграция с роботом**: Общение с физическим роботом для зеркалирования ходов, сделанных в приложении, на реальной шахматной доске.
3. **Пользовательский интерфейс**: Разработка интуитивно понятного интерфейса, который позволяет пользователям взаимодействовать с шахматной игрой, видеть допустимые ходы и получать обратную связь о состоянии игры.

### Ключевые Компоненты и Алгоритмы

1. **Представление шахматных фигур и доски**:
    - Шахматная доска представлена в виде сетки 8x8 объектов `ChessPiece`, которые могут быть пешками, ладьями, конями, слонами, ферзями и королями. Эти объекты описаны в модели `chess_pieces.dart`.

2. **Модель представления (ViewModel)**:
    - `ChessBoardViewModel` управляет состоянием шахматной доски, выбранными фигурами и возможными ходами. Он также обрабатывает логику игры, такую как определение шаха и мата.
    - Логика игры реализована с помощью методов для выбора фигур (`selectPiece`), выполнения ходов (`movePiece`) и проверки условий шаха и мата (`isCheck`, `isCheckMate`).

3. **Интеграция с роботом**:
    - Сервис `ChessRobotService` обеспечивает связь с роботом через TCP/IP. Он отправляет команды роботу для перемещения фигур на реальной доске.
    - Метод `movePieceWithRobot` в `ChessBoardViewModel` вызывает сервис для перемещения фигуры и управляет процессом перемещения убитых фигур на другую доску.

4. **Управление ходами и их запись**:
    - Класс `BoardReSetter` управляет стеком ходов, позволяя откатывать ходы для возврата фигур на начальные позиции.
    - В файле chess_pieces.dart определены классы, представляющие различные шахматные фигуры: пешка (Pawn), король (King), ферзь (Queen), конь (Knight), ладья (Rook) и слон (Bishop). Каждый класс реализует метод 'validMoves', который возвращает список возможных ходов для данной фигуры на шахматной доске. Эти классы являются частью модели шахматной доски и предоставляют основу для реализации логики игры. Каждая фигура имеет свои правила движения, и метод validMoves реализует эти правила, возвращая список допустимых ходов для каждой фигуры в заданной позиции на доске.
    - Метод `addMove` записывает каждый ход в стек, а метод `reset` выполняет откат всех ходов в обратном порядке.

### Интересные Решения

1. **Алгоритм расчета возможных ходов**:
    - Метод `simulateFutureMove` вычисляет все возможные ходы для заданной фигуры и проверяет их на безопасность (не приводит ли ход к шаху).
    - Алгоритм использует метод `futureMoveIsSafe`, чтобы убедиться, что ход не подвергает короля опасности.

2. **Запись и откат ходов**:
    - Использование очереди для записи ходов позволяет легко реализовать функцию отката, что особенно полезно при тестировании и отладке.

3. **Интеграция с роботом**:
    - Для реализации механизма связи с роботом, была переписана open-source библиотека с [pub.dev]([https://pub.dev](https://pub.dev/packages/tcp_socket_connection))
    - Класс TcpSocketConnection отвечает за управление TCP-соединением с роботом. Он предоставляет методы для инициализации соединения (connect), отправки сообщений на робота (sendMessage) и проверки соединения (canConnect). Также он обрабатывает события, получаемые от робота, вызывая колбэк-функцию для обработки полученных данных. Так мы достигли следующего поведения: пользователь на своем устройстве делает ход, который моментально отображается на экране, робот начинает свою работу по перемещению фигуры, и только после того как робот закончил выполнение действия, ход передается другому цвету фигур.
  
### Подводные камни
Изначально в планах было создать web-приложение, однако в процессе разработки мы поняли, что используя только flutter - это невозможно. Дело в том, что TCP протокол напрямую не поддерживается в веб-браузерах. Основные причины отсутствия поддержки TCP в веб-браузерах:

1. **Ограничения безопасности**: TCP-протокол обычно используется для низкоуровневого обмена данными, и его применение напрямую в веб-браузере может создавать уязвимости безопасности, такие как возможность для злоумышленников сканировать и атаковать сеть пользователя.

2. **Ограничения политики безопасности браузера**: Браузеры имеют строгие политики безопасности, которые контролируют, какие ресурсы могут быть запрошены и доступны в веб-приложениях. Для TCP-соединений, особенно для их создания из веб-приложений, требуется прямой доступ к сетевым ресурсам, что может быть нежелательным из соображений безопасности.

В связи с этими причинами, рекомендуется использовать HTTP или WebSocket. Однако, для нашей задачи такие соединения не подошли (в первом случае соединение не устанавливалось, во втором - "крашило" роботв

В следствие все выше сказанного, мы остановились на создании desktop windows и android приложений

### Архитектура проекта

Архитектура проекта в основоном основывается на принципах Clean Architecture
#### Подробно о каждом из слоев

#### Data

Это слой работы с данными. На этом уровне, описываем работу обращения к роботу-манипулятору, то есть внешнему api

Структура нашего слоя `data` выглядит так:

```
├── service
      ├── chess_robot_service.dart
      ├── tcp_connection.dart
```

`services` - уровень для работы с данными (здесь происходят конкретные запросы
   к источнику данных);

#### Domain

Cтруктура слоя `domain` выглядит так:

```
├── models
│   └── model.dart
```
'model.dart' - класс, например ChessPiece

#### Presentation

Это слой пользовательского интерфейса.
Он не имеет логического представления и взаимодействует с данными исключительно посредством менеджера состояний (в нашем случае через view_model).

Типичная структура слоя `presentation` выглядит так:
```
presentation
├── view
│   ├── widgets
│       └── widget.dart
│   └── feature_view.dart
└── view_model
    └── feature_view_model.dart
```

В папке 'core' (lib/core) находятся иконки, стили текста, цветов, а также константы - ip и port робота

Таким образом, дерево всего проекта выглядит следующим образом

```
lib
├── core
├── feature
│    └── chessboard
│        ├── data
│        ├── domain
│        └── presentaion.dart
└── main.dart

```

## Структура проекта

Структура проекта организована по принципу `feature-by-layer`. Это значит, что разделение на слои происходит в каждой отдельной `feature`.

Несмотря на то, что на данный момент в проекте всего одна 'feature', мы выбрали такую структуру для удобного дальнейшего развития проекта и внедрения новых 'features'.

## To do
- [x] Интерфейс
- [x] Определение правильных шагов
- [x] Шах, шах и мат
- [x] Подключение к роботу через tcp/ip протокол
- [x] Проверено на стенде
- [x] Перезапуск игры
- [x] Установщик для windows и APK file для Android
- [ ] Игра в шахматы против соперника, с повторением движений роботом.
- [ ] Игра в шахматы против искусственного интеллекта, управляющего роботом.
- [ ] Начало игры с произвольной расстановкой фигур на поле


## Команда проекта

- [Погребняк Кирилл](https://t.me/kroll4) — Flutter Developer
- [Ершов Артем](https://t.me/naxyo3) — Flutter Developer
